#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <locale.h>
#include <Windows.h>
#define _CRT_SECURE_NO_WARNINGS_
// ФУНКЦИЯ КОТОРАЯ ВОЗВРАЩАЕТ 1, ЕСЛИ СИМВОЛ - ПРОБЕЛ, ЗНАК НОВОЙ СТРОКИ ИЛИ ТАБУЛЯЦИЯ, И 0 В ПРОТИВНОМ СЛУЧАЕ
int space(char symbol)
    {
    char space_symbols[3] = { '\n',  '' , '\t};

    for (int i = 0; i < 3; i++)
    {
        if (symbol == space_symbols[i])
            return 1;
    }
    return 0;
    }
        // ФУНКЦИЯ, КОТОРАЯ ВОЗВРАЩАЕТ 1, ЕСЛИ СИМВОЛ ЧИСЛО, И 0 ЕСЛИ НЕТ
        int digit(char symbol)
    {
        char digits[10] = { '1', '2', '3', '4', '5', '6', '7', '8', '9' };
        for (int i = 0; i < 10; i++)
        {
            if (symbol == digits[i])
                return 1;
        }
        return 0;
    }
    // ФУНКЦИЯ, КОТОРАЯ ПЕРЕВОДИТ СТРОКУ В ЧИСЛО
    int CtoD(char* string)
    {
        int n = 0; int i = 0;
        for (int i = 0; space(string[i]); i++) // если вдруг придется вводить строки от руки, а не рандомить, то с помощью этого цикла мы пропускаем все пробелы(функция isspace)
            i++; // если мы встречаем пробел, то просто увеличиваем индекс и пропускаем его, не производя над ним никаких махинаций
        for (n = 0; digit(string[i]); i++)
            n = 10 * n + (string[i] - '0'); // пока мы встречаем число, умножаем его на 10, на само себя, и прибавляем элемент строки(число) отнимая от него нуль-символ
                   // просто формула, чтобы перевести строку из чисел в число
        return n; // в конце возвращаем число
    }
    int main()
    {
        setlocale(LC_ALL, "Russian"); // подключаем русскую локализацию, чтобы можно было выводить на русском языке
        char** txt = NULL; // создаем массив строк и присваем ему значение NULL(т.е. 0) в самом начале
        int* dtxt = NULL; // создаем новый массив типа int, в который будем перемещать числа из первого переведнные в int
        int n, m; // переменная n - количество строк в массиве символов, m - количество символов в каждой строке массива
        printf("Введите количество строк: ");
        scanf_s("%d", &n);
        printf("\nВведите количество символов в каждой строке: ");
        scanf_s("%d", &m);
        system("CLS"); // очистка консоли(экрана), после того как ввели размерность массива

        txt = (char**)malloc(n * m * sizeof(char)); // выделяем память под массив строк
        dtxt = (int*)malloc(n * sizeof(int)); // выделяем память под интовый массив. Умножаем на n потому что в нем будет столько же чисел,
                                                       //сколько строк в первом массиве,
                                                       //т.к. каждая его строка - это число, только типа char

        for (int i = 0; i < n; i++) // с помощью цикла выделяем память под каждую строку массива строк(в каждой строке m элементов)
            txt[i] = (char*)calloc(m, sizeof(char));

        for (int i = 0; i < n; i++) // заполнение массива строк рандомными числами от 1 до 9
            for (int j = 0; j < m; j++)
                txt[i][j] = ('1' + rand() % ('9' - '1')); // присваиваем элементу массива строк рандомное значение от 1 до 9

                   // вывод массива строк
        printf("\nИзначальный массив:\n");
        for (int i = 0; i < n; i++, putchar('\n'))
            for (int j = 0; j < m; j++)
                printf("%c", txt[i][j]);

        putchar('\n'); // пропускаем одну строку, чтобы красиво все выводить

        // перевод массива из char в int чтобы можно было сортировать
        int k = 0; // индекс k в самом начале равен нулю
        for (int i = 0; i < n; i++) // начинаем цикл прохода по массиву строк
        {
            dtxt[k] = CtoD(txt[i]); // присваиваем элементу нового массива значение возвращаемое функцией CtoD, то есть строку, переведенную в число
            k++; // увеличиваем индекс k в каждой итерации, чтобы переходить к следующему элементу нового массива
        }
        // выводим массив до сортировки
        printf("\nДо сортировки:\n");
        for (int i = 0; i < n; i++)
            printf("%d\n", dtxt[i]);

        //сортировка
        // сравниваем два соседних элемента
        for (int i = 0; i < n - 1; i++)
        {
            for (int j = 0; j < n - i - 1; j++)
            {
                // если они идут в неправильном порядке, т.е. не по убыванию, то меняем их местами
                if (dtxt[j] < dtxt[j + 1])
                {
                    int tmp = dtxt[j]; // сохраняем элемент в переменную tmp
                    dtxt[j] = dtxt[j + 1]; // на место этого элемента ставим следующий
                    dtxt[j + 1] = tmp; // а следующему присваиваем значение переменной tmp, в которую мы сохранили текущий элемент
                }
            }
        }

        putchar('\n'); // снова пропускаем строку для красивого вывода
        printf("\nПосле сортировки:\n"); // выводим массив после сортировки
        for (int i = 0; i < n; i++)
            printf("%d\n", dtxt[i]);

        // освобождаем всю память, которую мы выделили
        for (int i = 0; i < n; i++)
            free(txt[i]);
        free(txt);
        free(dtxt);
        return 0;
    }